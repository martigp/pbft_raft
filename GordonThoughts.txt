struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

       union epoll_data {
           void     *ptr;
           int       fd;
           uint32_t  u32;
           uint64_t  u64;
       };

       typedef union epoll_data  epoll_data_t;

epoll can data can have an associated ptr. If this points to a structure
that has all the necessary information to handle incoming messages this would
be a good abstraction.

Incoming messages -> want to handle it appropriately. This will involve doing
a general purpose parsing and passing it down to a relevant submodule
    - TODO: Design decision as to what the subhandler interface should be, 
    - Method a) Dividing subhandler by RaftClient and RaftServer
    - Method b) Dividing subhandler by req and reso(i.e. client v.s. server)

    Method a)

    Three approaches

    1) Potential to obtain this information from the socket information -> from
    class this seems like an approach he wouldn't want.

    2) Encode this information in the message itself i.e. some high level field
    that says whether it is from a RaftServer or client

    3) Parse all the way down to the RPC type e.g. RaftClientRPC v.s.
    RaftServerRPC

    Method b)

    Will require some knowledge of it being client v.s. server socket
    1) Similar to 1 from above, reasons why I think this doesn't make sense
    unless we somehow divide socket polling by connections we have initiated vs
    connections that we didn't. Not sure if this is really feasible or desirable

    2) Parse even further down to RPC type e.g. AppendEntries::Request

    Method c) 
    Enocde events.data.ptr a pointer to the thing that will deal with
    everything in response to an event on this socket? This seems pretty cool
    from a design perspective because we can treat polling somewhat agnostically

    Can then separate by Client / Server (request v.s. response).

    Server should have some array of sockets 



    /* General purpose socket abstraction to allow for response to events on
       the socket. */
    public class Socket {
        
        /* Socket File Descriptor */
        int fd;

        /* Handle EPOLL event on the socket. */)
        virtual void handleSocketEvent(uint32_t events);
    }

    /* Socket that listens for incoming connections. */
    class ListenerSocket : public Socket {

        list[str] = addreses (cross reference with what you accept)

        /* Accepts valid connections and add the new socket to the list of 
         * sockets polled for events. Drops any invalid connections. */
        void handleSocketEvent()
    }

    /* This can be for a RaftClient or RaftServer */
    class ServerSocket : public Socket {
        
        /* Process request messages recieved from a client. */
        void handleSocketEvent()

        /* TODO: Will  need some additional members to do this processing 
         * Additionally, not sure what na event on an accepted socket is, is
         * this when it is readable or when received a messaged? */
    }

    class RaftC2SSocket : public ServerSocket {

    }

    class RaftS2SSocket : public ServerSocket {

    }


    timerThread

    Leader: heartbeat
        Send out RPCs only when heartbeatTimer goes off
    Candidate: electionTimeout
        Wait for electionTimeout to finish to decide whether you are leader
    Follower: electionTimeout
        Become a candidate when electionTimeout goes off


    
    Polling Thread:

    class RaftServer

    /* This class will have already sent its request and will therefore be
     * waiting for a response from a server.
     * TODO: Deal with timeouts.
     */
    class ClientSocket : public Socket {
        /* Process response messages received from a server.  */
        void handleSocketEvent()

        /* TODO: Will  need some additional members to do this processing
         * Additionally, not sure what an event on a connected socket is, is
         * this when writeable or when received a messaged? */

    }

    
    Alternatively these two classes could be merged into one which is just an
    established socket that you can read and write to (since we'll be doing
    both from both of these sockets). The reason we would differentiate is
    because we want to do two different things with these.

    On a ConnectedSocket (i.e. you are the client), you want want to send some
    data and either receive the response or resent after some timeouts

    On an accepted socket you are simply listening and then sending a response.

